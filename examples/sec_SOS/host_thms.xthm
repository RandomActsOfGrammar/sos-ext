Module sec_SOS:host.

Translation_Constraint trans_e_unique : forall E E1 E2,
  |{e}- E ~~> E1 -> |{e}- E ~~> E2 -> E1 = E2.
Translation_Constraint trans_e_is : forall E E',
  |{e}- E ~~> E' -> is_e E -> is_e E'.

Translation_Constraint trans_rf_unique : forall RF RF1 RF2,
  |{recFieldExprs}- RF ~~> RF1 ->
  |{recFieldExprs}- RF ~~> RF2 ->
  RF1 = RF2.
Translation_Constraint trans_rf_is : forall RF RF',
  |{recFieldExprs}- RF ~~> RF' -> is_recFieldExprs RF ->
  is_recFieldExprs RF'.

Translation_Constraint trans_c_unique : forall C C1 C2,
  |{c}- C ~~> C1 -> |{c}- C ~~> C2 -> C1 = C2.
Translation_Constraint trans_c_is : forall C C',
  |{c}- C ~~> C' -> is_c C -> is_c C'.

Translation_Constraint trans_recFields_unique : forall RF RF1 RF2,
  |{recFields}- RF ~~> RF1 -> |{recFields}- RF ~~> RF2 -> RF1 = RF2.
Translation_Constraint trans_recFields_is : forall RF RF',
  |{recFields}- RF ~~> RF' -> is_recFields RF -> is_recFields RF'.

Translation_Constraint trans_ty_unique : forall Ty Ty1 Ty2,
  |{ty}- Ty ~~> Ty1 -> |{ty}- Ty ~~> Ty2 -> Ty1 = Ty2.
Translation_Constraint trans_ty_is : forall Ty Ty',
  |{ty}- Ty ~~> Ty' -> is_ty Ty -> is_ty Ty'.

Translation_Constraint trans_value_unique : forall V V1 V2,
  |{value}- V ~~> V1 -> |{value}- V ~~> V2 -> V1 = V2.
Translation_Constraint trans_value_is : forall V V',
  |{value}- V ~~> V' -> is_value V -> is_value V'.


Translation_Constraint trans_domain_mem_fwd : forall D D' X,
  |{domain}- D ~~> D' -> memDomain X D -> memDomain X D'.

Translation_Constraint trans_domain_mem_back : forall D D' X,
  |{domain}- D ~~> D' -> memDomain X D' -> memDomain X D.


Extensible_Theorem
  joinDomains_unique : forall D1 D2 R1 R2,
    J1 : joinDomains D1 D2 R1 ->
    J2 : joinDomains D1 D2 R2 ->
    R1 = R2
  on J1.
%JD-Empty
 case J2. search.
%JD-Add
 J2: case J2. apply IH to J3 J2. search.


Extensible_Theorem
  joinDomains_total : forall D1 D2,
    IsD1 : is_domain D1 ->
    IsD2 : is_domain D2 ->
    exists D, joinDomains D1 D2 D
  on IsD1.
%JD-Empty
 search.
%JD-Add
 apply IH to IsD4 IsD2. search.


Extensible_Theorem
  joinDomains_empty_right : forall D1 D2,
    J : joinDomains D1 emptyDomain D2 ->
    D1 = D2
  on J.
%JD-Empty
 search.
%JD-Add
 apply IH to J1. search.


Extensible_Theorem
  joinDomains_is : forall D1 D2 D,
    IsD1 : is_domain D1 ->
    IsD2 : is_domain D2 ->
    J : joinDomains D1 D2 D ->
    is_domain D
  on J.
%JD-Empty
 search.
%JD-Add
 IsD1: case IsD1. apply IH to IsD3 IsD2 J1. search.


Extensible_Theorem
  joinDomains_assoc : forall D1 D2 D3 D12 D23 D D',
    J1 : joinDomains D1 D2 D12 ->
    J2 : joinDomains D12 D3 D ->
    J3 : joinDomains D2 D3 D23 ->
    J4 : joinDomains D1 D23 D' ->
    D = D'
  on J1.
%JD-Empty
 case J4. apply joinDomains_unique to J2 J3. search.
%JD-Add
 case J2. case J4. apply IH to J5 H1 J3 H2. search.


Extensible_Theorem
  join_something_join_anything : forall D1 D2 D D3,
    J : joinDomains D1 D2 D ->
    exists D', joinDomains D1 D3 D'
  on J.
%JD-Empty
 search.
%JD-Add
 apply IH to J1 with D3 = D3. search.


Extensible_Theorem
  join_joined : forall D1 D11 D111 D2 D22 D222 D,
    J1 : joinDomains D1 D11 D111 ->
    J2 : joinDomains D2 D22 D222 ->
    J3 : joinDomains D1 D2 D ->
    exists D', joinDomains D D22 D'
  on J1.
%JD-Empty
 case J1. case J3. search.
%JD-Add
 case J3. apply IH to J4 J2 H1. search.


Extensible_Theorem
  joinDomains_mem : forall D1 D2 D X,
    J : joinDomains D1 D2 D ->
    Mem : memDomain X D ->
    memDomain X D1 \/ memDomain X D2
  on J.
%JD-Empty
 search.
%JD-Add
 Mem: case Mem.
   %mem here
    search.
   %mem later
    Or: apply IH to J1 Mem. Mem': case Or.
      %mem D3
       search.
      %mem D2
       search.


Extensible_Theorem
  mem_joinDomains1 : forall D1 D2 D X,
    J : joinDomains D1 D2 D ->
    Mem : memDomain X D1 ->
    memDomain X D
  on J.
%JD-Empty
 case Mem.
%JD-Add
 Mem: case Mem.
   %mem here
    search.
   %mem later
    apply IH to J1 Mem. search.
Extensible_Theorem
  mem_joinDomains2 : forall D1 D2 D X,
    J : joinDomains D1 D2 D ->
    Mem : memDomain X D2 ->
    memDomain X D
  on J.
%JD-Empty
 search.
%JD-Add
 apply IH to J1 Mem. search.


Extensible_Theorem
  vars_join : forall E V D,
    Vars : vars E V ->
    exists D', joinDomains V D D'
  on Vars,
  vars_rf_join : forall RF V D,
    Vars : vars_rf RF V ->
    exists D', joinDomains V D D'
  on Vars.
%vars_unique
 %V-Num
  search.
 %V-Plus
  J2: apply IH to Vars2 with D = D. J1: apply IH to Vars1 with D = D'.
  apply join_joined to J1 J2 Vars3.
  apply join_something_join_anything to H1 with D3 = D. search.
 %V-Name
  search.
 %V-Greater
  J2: apply IH to Vars2 with D = D. J1: apply IH to Vars1 with D = D'.
  apply join_joined to J1 J2 Vars3.
  apply join_something_join_anything to H1 with D3 = D. search.
 %V-Eq
  J2: apply IH to Vars2 with D = D. J1: apply IH to Vars1 with D = D'.
  apply join_joined to J1 J2 Vars3.
  apply join_something_join_anything to H1 with D3 = D. search.
 %V-And
  J2: apply IH to Vars2 with D = D. J1: apply IH to Vars1 with D = D'.
  apply join_joined to J1 J2 Vars3.
  apply join_something_join_anything to H1 with D3 = D. search.
 %V-Or
  J2: apply IH to Vars2 with D = D. J1: apply IH to Vars1 with D = D'.
  apply join_joined to J1 J2 Vars3.
  apply join_something_join_anything to H1 with D3 = D. search.
 %V-True
  search.
 %V-False
  search.
 %V-RecBuild
  apply IH1 to Vars1 with D = D. search.
 %V-RecAccess
  apply IH to Vars1 with D = D. search.
%vars_rf_unique
 %VRF-Empty
  search.
 %VRF-Add
  J2: apply IH1 to Vars1 with D = D. J1: apply IH to Vars2 with D = D'.
  apply join_joined to J1 J2 Vars3.
  apply join_something_join_anything to H1 with D3 = D. search.


Extensible_Theorem
  vars_unique : forall E V1 V2,
    Vars1 : vars E V1 ->
    Vars2 : vars E V2 ->
    V1 = V2
  on Vars1,
  vars_rf_unique : forall RF V1 V2,
    Vars1 : vars_rf RF V1 ->
    Vars2 : vars_rf RF V2 ->
    V1 = V2
  on Vars1.
%vars_unique
 %V-Num
  case Vars2. search.
 %V-Plus
  Vars2: case Vars2. apply IH to Vars3 Vars2. apply IH to Vars4 Vars6.
  apply joinDomains_unique to Vars5 Vars7. search.
 %V-Name
  case Vars2. search.
 %V-Greater
  Vars2: case Vars2. apply IH to Vars3 Vars2. apply IH to Vars4 Vars6.
  apply joinDomains_unique to Vars5 Vars7. search.
 %V-Eq
  Vars2: case Vars2. apply IH to Vars3 Vars2. apply IH to Vars4 Vars6.
  apply joinDomains_unique to Vars5 Vars7. search.
 %V-And
  Vars2: case Vars2. apply IH to Vars3 Vars2. apply IH to Vars4 Vars6.
  apply joinDomains_unique to Vars5 Vars7. search.
 %V-Or
  Vars2: case Vars2. apply IH to Vars3 Vars2. apply IH to Vars4 Vars6.
  apply joinDomains_unique to Vars5 Vars7. search.
 %V-True
  case Vars2. search.
 %V-False
  case Vars2. search.
 %V-RecBuild
  Vars2: case Vars2. apply IH1 to Vars3 Vars2. search.
 %V-RecAccess
  Vars2: case Vars2. apply IH to Vars3 Vars2. search.
%vars_rf_unique
 %VRF-Empty
  case Vars2. search.
 %VRF-Add
  Vars2: case Vars2. apply IH to Vars4 Vars6.
  apply IH1 to Vars3 Vars2. apply joinDomains_unique to Vars5 Vars7.
  search.


Translation_Constraint trans_e_vars_exist : forall E E' V,
  |{e}- E ~~> E' -> vars E V -> exists V', vars E' V'.
Translation_Constraint trans_e_vars : forall E E' V V' X,
  |{e}- E ~~> E' -> vars E V -> vars E' V' ->
  memDomain X V -> memDomain X V'.

Translation_Constraint trans_rf_vars_exist : forall RF RF' V,
  |{recFieldExprs}- RF ~~> RF' -> vars_rf RF V ->
  exists V', vars_rf RF' V'.
Translation_Constraint trans_rf_vars : forall RF RF' V V' X,
  |{recFieldExprs}- RF ~~> RF' -> vars_rf RF V -> vars_rf RF' V' ->
  memDomain X V -> memDomain X V'.


Extensible_Theorem
  vars_is : forall E V,
    IsE : is_e E ->
    Vars : vars E V ->
    is_domain V
  on Vars,
  vars_rf_is : forall RF V,
    IsRF : is_recFieldExprs RF ->
    Vars : vars_rf RF V ->
    is_domain V
  on Vars.
%vars_is
  %V-Num
   search.
  %V-Plus
   IsE1: case IsE. IsD1: apply IH to IsE1 Vars1.
   IsD2: apply IH to IsE2 Vars2.
   apply joinDomains_is to IsD1 IsD2 Vars3. search.
  %V-Name
   case IsE. search.
  %V-Greater
   IsE1: case IsE. IsD1: apply IH to IsE1 Vars1.
   IsD2: apply IH to IsE2 Vars2.
   apply joinDomains_is to IsD1 IsD2 Vars3. search.
  %V-Eq
   IsE1: case IsE. IsD1: apply IH to IsE1 Vars1.
   IsD2: apply IH to IsE2 Vars2.
   apply joinDomains_is to IsD1 IsD2 Vars3. search.
  %V-And
   IsE1: case IsE. IsD1: apply IH to IsE1 Vars1.
   IsD2: apply IH to IsE2 Vars2.
   apply joinDomains_is to IsD1 IsD2 Vars3. search.
  %V-Or
   IsE1: case IsE. IsD1: apply IH to IsE1 Vars1.
   IsD2: apply IH to IsE2 Vars2.
   apply joinDomains_is to IsD1 IsD2 Vars3. search.
  %V-True
   search.
  %V-False
   search.
  %V-RecBuild
   IsRF: case IsE. apply IH1 to IsRF Vars1. search.
  %V-RecAccess
   IsE: case IsE. apply IH to IsE Vars1. search.
%vars_rf_is
  %VRF-Empty
   search.
  %VRF-Add
   IsRF: case IsRF. IsDE: apply IH to IsRF1 Vars2.
   IsDRest: apply IH1 to IsRF2 Vars1.
   apply joinDomains_is to IsDE IsDRest Vars3. search.


Extensible_Theorem
  vars_exist : forall E,
    IsE : is_e E ->
    exists V, vars E V
  on IsE,
  vars_rf_exist : forall RF,
    IsRF : is_recFieldExprs RF ->
    exists V, vars_rf RF V
  on IsRF.
%vars_exist
  %num
   search.
  %plus
   Vars1: apply IH to IsE1. Vars2: apply IH to IsE2.
   IsV: apply vars_is to IsE1 Vars1.
   IsV1: apply vars_is to IsE2 Vars2.
   apply joinDomains_total to IsV IsV1. search.
  %name
   search.
  %greater
   Vars1: apply IH to IsE1. Vars2: apply IH to IsE2.
   IsV: apply vars_is to IsE1 Vars1.
   IsV1: apply vars_is to IsE2 Vars2.
   apply joinDomains_total to IsV IsV1. search.
  %eq
   Vars1: apply IH to IsE1. Vars2: apply IH to IsE2.
   IsV: apply vars_is to IsE1 Vars1.
   IsV1: apply vars_is to IsE2 Vars2.
   apply joinDomains_total to IsV IsV1. search.
  %and
   Vars1: apply IH to IsE1. Vars2: apply IH to IsE2.
   IsV: apply vars_is to IsE1 Vars1.
   IsV1: apply vars_is to IsE2 Vars2.
   apply joinDomains_total to IsV IsV1. search.
  %or
   Vars1: apply IH to IsE1. Vars2: apply IH to IsE2.
   IsV: apply vars_is to IsE1 Vars1.
   IsV1: apply vars_is to IsE2 Vars2.
   apply joinDomains_total to IsV IsV1. search.
  %true
   search.
  %false
   search.
  %rec build
   apply IH1 to IsE1. search.
  %rec field access
   apply IH to IsE1. search.
%vars_rf_exist
  %endRecFieldExprs
   search.
  %addRecFieldExprs
   VarsE: apply IH to IsRF2. VarsRest: apply IH1 to IsRF3.
   IsV: apply vars_is to IsRF2 VarsE.
   IsV1: apply vars_rf_is to IsRF3 VarsRest.
   apply joinDomains_total to IsV IsV1. search.


Extensible_Theorem
  lookupTy_unique : forall G X T1 T2,
    Lkp1: lookupTy G X T1 ->
    Lkp2: lookupTy G X T2 ->
    T1 = T2
  on Lkp1.
%1 by LV-Here
 Lkp2: case Lkp2.
   %2 by LV-Here
    search.
   %2 by LV-Later
    apply Lkp3 to _.
%1 by LV-Later
 Lkp2: case Lkp2.
   %2 by LV-Here
    apply Lkp4 to _.
   %2 by LV-Later
    apply IH to Lkp3 Lkp2. search.


Extensible_Theorem
  typeOf_unique : forall G E T1 T2,
    Ty1: typeOf G E T1 ->
    Ty2: typeOf G E T2 ->
    T1 = T2
  on Ty1,
  typeRecFields_unique : forall G RF T1 T2,
    Ty1: typeRecFields G RF T1 ->
    Ty2: typeRecFields G RF T2 ->
    T1 = T2
  on Ty1.
%typeOf_unique
  %T-Num
   case Ty2. search.
  %T-Plus
   Ty2: case Ty2. search.
  %T-Name
   Ty2: case Ty2. apply lookupTy_unique to Ty3 Ty2. search.
  %T-Greater
   Ty2: case Ty2. search.
  %T-Eq
   Ty2: case Ty2. apply IH to Ty3 Ty2. search.
  %T-And
   case Ty2. search.
  %T-Or
   case Ty2. search.
  %T-True
   case Ty2. search.
  %T-False
   case Ty2. search.
  %T-RecBuild
   Ty2: case Ty2. apply IH1 to Ty3 Ty2. search.
  %T-RecField
   Ty2: case Ty2. apply IH to Ty3 Ty2.
   apply lookupTy_unique to Ty4 Ty5. search.
%typeRecFields_unique
  %TRF-End
   case Ty2. search.
  %TRF-Add
   Ty2: case Ty2. apply IH to Ty3 Ty2. apply IH1 to Ty4 Ty6. search.


Extensible_Theorem
  typeOK_unique : forall G C G1 G2,
    Ty1: typeOK G C G1 ->
    Ty2: typeOK G C G2 ->
    G1 = G2
  on Ty1.
%T-Noop
 case Ty2. search.
%T-Seq
 Ty2: case Ty2. apply IH to Ty3 Ty2. apply IH to Ty4 Ty5. search.
%T-Declare
 Ty2: case Ty2. apply typeOf_unique to Ty4 Ty5. search.
%T-Assign
 Ty2: case Ty2. apply typeOf_unique to Ty3 Ty2. search.
%T-IfThenElse
 Ty2: case Ty2. search.
%T-While
 Ty2: case Ty2. apply IH to Ty4 Ty5. search.
%T-RecUpdate
 Ty2: case Ty2. search.


Extensible_Theorem
  lookupVal_unique : forall G X V1 V2,
    Lkp1: lookupVal G X V1 ->
    Lkp2: lookupVal G X V2 ->
    V1 = V2
  on Lkp1.
%1 by LV-Here
 Lkp2: case Lkp2.
   %2 by LV-Here
    search.
   %2 by LV-Later
    apply Lkp3 to _.
%1 by LV-Later
 Lkp2: case Lkp2.
   %2 by LV-Here
    apply Lkp4 to _.
   %2 by LV-Later
    apply IH to Lkp3 Lkp2. search.


Translation_Constraint trans_eval_e : forall G E E' V,
  |{e}- E ~~> E' -> eval_e G E V ->
  exists V', eval_e G E' V'.


Extensible_Theorem
  eval_e_unique : forall G E V1 V2,
    Ev1: eval_e G E V1 ->
    Ev2: eval_e G E V2 ->
    V1 = V2
  on Ev1,
  eval_rf_unique : forall G RF V1 V2,
    Ev1: eval_rf G RF V1 ->
    Ev2: eval_rf G RF V2 ->
    V1 = V2
  on Ev1.
%1:  eval_e_unique
  %1.1:  1 by E-Num
   case Ev2. search.
  %1.2:  1 by E-Plus
   Ev2: case Ev2. apply IH to Ev3 Ev2. apply IH to Ev4 Ev6.
   apply plus_integer_unique to Ev5 Ev7. search.
  %1.3:  1 by E-Name
   Ev2: case Ev2. apply lookupVal_unique to Ev3 Ev2. search.
  %1.4:  1 by E-GreaterTrue
   Ev2: case Ev2.
     %1.4.1:  2 by E-GreaterTrue
      search.
     %1.4.2:  2 by E-GreaterFalse
      apply IH to Ev3 Ev2. apply IH to Ev4 Ev6.
      apply greater_lesseq_integer_false to Ev5 Ev7.
  %1.5:  1 by E-GreaterFalse
   Ev2: case Ev2.
     %1.5.1:  2 by E-GreaterTrue
      apply IH to Ev3 Ev2. apply IH to Ev4 Ev6.
      apply greater_lesseq_integer_false to Ev7 Ev5.
     %1.5.2:  2 by E-GreaterFalse
      search.
  %1.6:  1 by E-EqTrue
   Ev2: case Ev2.
     %1.6.1:  2 by E-EqTrue
      search.
     %1.6.2:  2 b5 E-EqFalse
      apply IH to Ev3 Ev2. apply IH to Ev4 Ev6. apply Ev7 to Ev5.
  %1.7:  1 by E-EqFalse
   Ev2: case Ev2.
     %1.7.1:  2 by E-EqTrue
      apply IH to Ev3 Ev2. apply IH to Ev4 Ev6. apply Ev5 to Ev7.
     %1.7.2:  2 by E-EqFalse
      search.
  %1.8:  1 by E-AndTrue
   Ev2: case Ev2.
     %1.8.1:  2 by E-AndTrue
      search.
     %1.8.2:  2 by E-AndFalse1
      apply IH to Ev3 Ev2.
     %1.8.3:  2 by E-AndFalse2
      apply IH to Ev4 Ev5.
  %1.9:  1 by E-AndFalse1
   Ev2: case Ev2.
     %1.9.1:  2 by E-AndTrue
      apply IH to Ev3 Ev2.
     %1.9.2:  2 by E-AndFalse1
      search.
     %1.9.3:  2 by E-AndFalse2
      search.
  %1.10:  1 by E-AndFalse2
   Ev2: case Ev2.
     %1.10.1:  2 by E-AndTrue
      apply IH to Ev4 Ev5.
     %1.10.2:  2 by E-AndFalse1
      search.
     %1.10.3:  2 by E-AndFalse2
      search.
  %1.11:  1 by E-OrTrue1
   Ev2: case Ev2.
     %1.11.1:  2 by E-OrTrue1
      search.
     %1.11.2:  2 by E-OrTrue2
      search.
     %1.11.3:  2 by E-orFalse
      apply IH to Ev3 Ev2.
  %1.12:  1 by E-OrTrue2
   Ev2: case Ev2.
     %1.12.1:  2 by E-OrTrue1
      search.
     %1.12.2:  2 by E-OrTrue2
      search.
     %1.12.3:  2 by E-OrFalse
      apply IH to Ev4 Ev5.
  %1.13:  1 by E-OrFalse
   Ev2: case Ev2.
     %1.13.1:  2 by E-OrTrue1
      apply IH to Ev3 Ev2.
     %1.13.2:  2 by E-OrTrue2
      apply IH to Ev4 Ev5.
     %1.13.3:  2 by E-OrFalse
      search.
  %1.14:  1 by E-True
   case Ev2. search.
  %1.15:  1 by E-False
   case Ev2. search.
  %1.16:  1 by E-RecBuild
   Ev2: case Ev2. apply IH1 to Ev3 Ev2. search.
  %1.17:  1 by E-RecField
   Ev2: case Ev2. apply IH to Ev3 Ev2.
   apply lookupVal_unique to Ev4 Ev5. search.
%2:  eval_rf_unique
 %2.1:  ERF-End
  case Ev2. search.
 %2.2:  ERF-Add
  Ev2: case Ev2. apply IH to Ev3 Ev2. apply IH1 to Ev4 Ev5. search.


Translation_Constraint trans_c_eval : forall C C' G G2,
  |{c}- C ~~> C' -> eval_c G C G2 -> exists G', eval_c G C' G'.
Translation_Constraint trans_c_eval_results :
  forall C C' G G1 G2 X V1 V2,
    |{c}- C ~~> C' -> eval_c G C G1 -> eval_c G C G2 ->
    lookupVal G1 X V1 -> lookupVal G2 X V2 -> V1 = V2.


Extensible_Theorem
  eval_c_unique : forall G C G1 G2,
    Ev1 : eval_c G C G1 ->
    Ev2 : eval_c G C G2 ->
    G1 = G2
  on Ev1,
  update_rec_fields_unique : forall F G V G1 G2,
    U1: update_rec_fields F G V G1 ->
    U2: update_rec_fields F G V G2 ->
    G1 = G2
  on U1.
%eval_c_unique
  %1 by E-Noop
   case Ev2. search.
  %1 by E-Seq
   Ev2: case Ev2. apply IH to Ev3 Ev2. apply IH to Ev4 Ev5. search.
  %1 by E-Declare
   Ev2: case Ev2. apply eval_e_unique to Ev3 Ev2. search.
  %1 by E-Assign
   Ev2: case Ev2. apply eval_e_unique to Ev3 Ev2. search.
  %1 by E-IfThenElseTrue
   Ev2: case Ev2.
     %2 by E-IfThenElseTrue
      apply IH to Ev4 Ev5. search.
     %2 by E-IfThenElseFalse
      apply eval_e_unique to Ev3 Ev2.
  %1 by E-IfThenElseFalse
   Ev2: case Ev2.
     %2 by E-IfThenElseTrue
      apply eval_e_unique to Ev3 Ev2.
     %2 by E-IfThenElseFalse
      apply IH to Ev4 Ev5. search.
  %1 by E-WhileFalse
   Ev2: case Ev2.
     %2 by E-WhileFalse
      search.
     %2 by E-WhileTrue
      apply eval_e_unique to Ev3 Ev2.
  %1 by E-WhileTrue
   Ev2: case Ev2.
     %2 by E-WhileFalse
      apply eval_e_unique to Ev3 Ev2.
     %2 by E-WhileTrue
      apply IH to Ev4 Ev6. apply IH to Ev5 Ev7. search.
  %1 by E-RecUpdate
   Ev2: case Ev2. apply lookupVal_unique to Ev4 Ev6.
   apply eval_e_unique to Ev3 Ev2. apply IH1 to Ev5 Ev7. search.
%update_rec_fields_unique
  %1 by URF-One
   case U2. search.
  %1 by URF-Step
   U2: case U2. apply lookupVal_unique to U3 U2. apply IH1 to U4 U5.
   search.


Extensible_Theorem
  memDomain_joinDomains_left : forall X D1 D2 D,
    Mem : memDomain X D1 ->
    J : joinDomains D1 D2 D ->
    memDomain X D
  on Mem.
%MD-Here
 case J. search.
%MD-Later
 J: case J. apply IH to Mem1 J. search.
Extensible_Theorem
  memDomain_joinDomains_right : forall X D1 D2 D,
    Mem : memDomain X D2 ->
    J : joinDomains D1 D2 D ->
    memDomain X D
  on J.
%JD-Empty
 search.
%JD-Add
 apply IH to Mem J1. search.


Theorem vars_equiv_left : forall G1 G2 D D1 D2,
  (forall X U1 U2, memDomain X D -> lookupVal G1 X U1 ->
                   lookupVal G2 X U2 -> U1 = U2) ->
  joinDomains D1 D2 D ->
  (forall X U1 U2, memDomain X D1 -> lookupVal G1 X U1 ->
                   lookupVal G2 X U2 -> U1 = U2).
intros Equiv J Mem Lkp1 Lkp2. backchain Equiv.
backchain memDomain_joinDomains_left.
Theorem vars_equiv_right : forall G1 G2 D D1 D2,
  (forall X U1 U2, memDomain X D -> lookupVal G1 X U1 ->
                   lookupVal G2 X U2 -> U1 = U2) ->
  joinDomains D1 D2 D ->
  (forall X U1 U2, memDomain X D2 -> lookupVal G1 X U1 ->
                   lookupVal G2 X U2 -> U1 = U2).
intros Equiv J Mem Lkp1 Lkp2. backchain Equiv.
backchain memDomain_joinDomains_right.


Extensible_Theorem
  vars_eval_same_result : forall G1 G2 E D V1 V2,
    Equiv : (forall X U1 U2,
                memDomain X D ->
                lookupVal G1 X U1 ->
                lookupVal G2 X U2 -> U1 = U2) ->
    Vars : vars E D ->
    Ev1 : eval_e G1 E V1 ->
    Ev2 : eval_e G2 E V2 ->
    V1 = V2
  on Ev1,
  vars_equal_rf_same_result : forall G1 G2 RF D V1 V2,
    Equiv : (forall X U1 U2,
                memDomain X D ->
                lookupVal G1 X U1 ->
                lookupVal G2 X U2 -> U1 = U2) ->
    Vars : vars_rf RF D ->
    Ev1 : eval_rf G1 RF V1 ->
    Ev2 : eval_rf G2 RF V2 ->
    V1 = V2
  on Ev1.
%vars_equal_same_result
  %1 by E-Num
   case Ev2. search.
  %1 by E-Plus
   Ev2: case Ev2. Vars1: case Vars.
   apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
   apply IH to _ Vars2 Ev4 Ev6. backchain vars_equiv_right.
   apply plus_integer_unique to Ev5 Ev7. search.
  %1 by E-Name
   Ev2: case Ev2. Vars: case Vars. apply Equiv to _ Ev3 Ev2. search.
  %1 by E-GreaterTrue
   Set subgoals off.
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-GreaterTrue
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
      apply IH to _ Vars2 Ev4 Ev6. backchain vars_equiv_right. search.
     %2 by E-GreaterFalse
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
      apply IH to _ Vars2 Ev4 Ev6. backchain vars_equiv_right.
      apply greater_lesseq_integer_false to Ev5 Ev7.
  %1 by E-GreaterFalse
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-GreaterTrue
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
      apply IH to _ Vars2 Ev4 Ev6. backchain vars_equiv_right.
      apply greater_lesseq_integer_false to Ev7 Ev5.
     %2 by E-GreaterFalse
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
      apply IH to _ Vars2 Ev4 Ev6. backchain vars_equiv_right. search.
  %1 by E-EqTrue
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-EqTrue
      search.
     %2 by E-EqFalse
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
      apply IH to _ Vars2 Ev4 Ev6. backchain vars_equiv_right.
      apply Ev7 to _.
  %1 by E-EqFalse
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-EqTrue
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
      apply IH to _ Vars2 Ev4 Ev6. backchain vars_equiv_right.
      apply Ev5 to _.
     %2 by E-EqFalse
      search.
  %1 by E-AndTrue
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-AndTrue
      search.
     %2 by E-AndFalse1
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
     %2 by E-AndFalse2
      apply IH to _ Vars2 Ev4 Ev5. backchain vars_equiv_right.
  %1 by E-AndFalse1
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-AndTrue
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
     %2 by E-AndFalse1
      search.
     %2 by E-AndFalse2
      search.
  %1 by E-Andfalse2
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-AndTrue
      apply IH to _ Vars2 Ev4 Ev5. backchain vars_equiv_right.
     %2 by E-AndFalse1
      search.
     %2 by E-AndFalse2
      search.
  %1 by E-OrTrue1
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-OrTrue1
      search.
     %2 by E-OrTrue2
      search.
     %2 by E-OrFalse
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
  %1 by E-OrTrue2
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-OrTrue1
      search.
     %2 by E-OrTrue2
      search.
     %2 by E-OrFalse
      apply IH to _Vars2 Ev4 Ev5. backchain vars_equiv_right.
  %1 by E-OrFalse
   Vars1: case Vars. Ev2: case Ev2.
     %2 by E-OrTrue1
      apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
     %2 by E-OrTrue2
      apply IH to _ Vars2 Ev4 Ev5. backchain vars_equiv_right.
     %2 by E-OrFalse
      search.
  %1 by E-True
   case Ev2. search.
  %1 by E-False
   case Ev2. search.
  %1 by E-RecBuild
   Vars: case Vars. Ev2: case Ev2. apply IH1 to _ Vars Ev3 Ev2.
   search.
  %1 by E-RecField
   Vars: case Vars. Ev2: case Ev2. apply IH to _ Vars Ev3 Ev2.
   apply lookupVal_unique to Ev4 Ev5. search.
%vars_equal_rf_same_result
  %1 by ERF-End
   case Ev2. search.
  %1 by ERF-Add
   Vars: case Vars. Ev2: case Ev2.
   apply IH to _ Vars1 Ev3 Ev2. backchain vars_equiv_left.
   apply IH1 to _ Vars Ev4 Ev5. backchain vars_equiv_right. search.
