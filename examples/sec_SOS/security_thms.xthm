Module sec_SOS:security.

Prove_Constraint sec_SOS:host:trans_e_unique.
Prove_Constraint sec_SOS:host:trans_e_is.
Prove_Constraint sec_SOS:host:trans_rf_unique.
Prove_Constraint sec_SOS:host:trans_rf_is.
Prove_Constraint sec_SOS:host:trans_c_unique.
%declareSec
 case Hyp1. search.
Prove_Constraint sec_SOS:host:trans_c_is.
%declareSec
 case Hyp1. search.
Prove_Constraint sec_SOS:host:trans_recFields_unique.
Prove_Constraint sec_SOS:host:trans_recFields_is.
Prove_Constraint sec_SOS:host:trans_ty_unique.
Prove_Constraint sec_SOS:host:trans_ty_is.
Prove_Constraint sec_SOS:host:trans_value_unique.
Prove_Constraint sec_SOS:host:trans_value_is.

Prove sec_SOS:host:vars_join,
      sec_SOS:host:vars_rf_join.

Prove sec_SOS:host:vars_unique,
      sec_SOS:host:vars_rf_unique.

Prove_Constraint sec_SOS:host:trans_e_vars_exist.
Prove_Constraint sec_SOS:host:trans_e_vars.
Prove_Constraint sec_SOS:host:trans_rf_vars_exist.
Prove_Constraint sec_SOS:host:trans_rf_vars.

Prove sec_SOS:host:vars_is, sec_SOS:host:vars_rf_is.
Prove sec_SOS:host:vars_exist, sec_SOS:host:vars_rf_exist.

Prove sec_SOS:host:typeOf_unique, sec_SOS:host:typeRecFields_unique.
Prove sec_SOS:host:typeOK_unique.
%declareSec
 Ty2: case Ty2. apply typeOf_unique to Ty4 Ty5. search.

Prove_Constraint sec_SOS:host:trans_eval_e.

Prove sec_SOS:host:eval_e_unique,
      sec_SOS:host:eval_rf_unique.

Prove sec_SOS:host:update_rec_fields_unique.

Prove_Constraint sec_SOS:host:trans_c_eval.
%declareSec
 Ev: case Hyp1. search.

Prove_Ext_Ind sec_SOS:host:eval_c.
%declareSec
 Trans: assert |{c}- declareSec X S Ty E ~~> declare X Ty E.
 assert <eval_c {T}> G (declare X Ty E) ((X, V)::G). search.

Prove sec_SOS:host:eval_c_unique.
%declareSec
 Ev2: case Ev2. apply eval_e_unique to Ev3 Ev2. search.

Prove_Constraint sec_SOS:host:trans_c_eval_results.
%declareSec
 Ev1: case Hyp1. Ev2: case Hyp2. apply eval_e_unique to Ev1 Ev2.
 search.

Prove sec_SOS:host:vars_eval_same_result,
      sec_SOS:host:vars_equal_rf_same_result.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                         SECURITY THEOREMS                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%We need this to make join_unique below possible
%Problem arises due to disallowed case analysis
Extensible_Theorem
  join_private : forall A S,
    Join : join A private S ->
    S = private
  on Join.
%J-Private 1
 search.
%J-Private 2
 search.
Extensible_Theorem
  join_unique : forall A B S1 S2,
    J1 : join A B S1 ->
    J2 : join A B S2 ->
    S1 = S2
  on J1.
%1 by J-Publics
 case J2. search.
%1 by J-Private1
 case J2. search. search.
%1 by J-Private 2
 apply join_private to J2. search.
Extensible_Theorem
  join_public : forall A B,
    J: join A B public ->
    A = public /\ B = public
  on J.
%J-Publics
 search.


Extensible_Theorem
  level_public_vars : forall SG E V X,
    Lev : level SG E public ->
    Vars : vars E V ->
    Mem : mem X V ->
    lookup SG X public
  on Lev,
  level_public_vars_rf : forall SG RF V X,
    Lev : rf_level SG RF public ->
    Vars : vars_rf RF V ->
    Mem : mem X V ->
    lookup SG X public
  on Lev.
%level_public_vars
  %S-Num
   case Vars. case Mem.
  %S-Plus
   Vars1: case Vars. apply join_public to Lev3.
   Or: apply mem_append to Mem Vars3. Mem': case Or.
     %mem D1
      apply IH to Lev1 Vars1 Mem'. search.
     %mem D2
      apply IH to Lev2 Vars2 Mem'. search.
  %S-Name
   case Vars. Mem': case Mem. search. case Mem'.
  %S-Greater
   Vars1: case Vars. apply join_public to Lev3.
   Or: apply mem_append to Mem Vars3. Mem': case Or.
     %mem D1
      apply IH to Lev1 Vars1 Mem'. search.
     %mem D2
      apply IH to Lev2 Vars2 Mem'. search.
  %S-Eq
   Vars1: case Vars. apply join_public to Lev3.
   Or: apply mem_append to Mem Vars3. Mem': case Or.
     %mem D1
      apply IH to Lev1 Vars1 Mem'. search.
     %mem D2
      apply IH to Lev2 Vars2 Mem'. search.
  %S-And
   Vars1: case Vars. apply join_public to Lev3.
   Or: apply mem_append to Mem Vars3. Mem': case Or.
     %mem D1
      apply IH to Lev1 Vars1 Mem'. search.
     %mem D2
      apply IH to Lev2 Vars2 Mem'. search.
  %S-Or
   Vars1: case Vars. apply join_public to Lev3.
   Or: apply mem_append to Mem Vars3. Mem': case Or.
     %mem D1
      apply IH to Lev1 Vars1 Mem'. search.
     %mem D2
      apply IH to Lev2 Vars2 Mem'. search.
  %S-True
   case Vars. case Mem.
  %S-False
   case Vars. case Mem.
  %S-RecBuild
   Vars: case Vars. apply IH1 to Lev1 Vars Mem. search.
  %S-RecField
   Vars: case Vars. apply IH to Lev1 Vars Mem. search.
  %Preservability
   V: apply trans_e_vars_exist to Lev1 Vars.
   Mem: apply trans_e_vars to Lev1 Vars V Mem.
   apply IH to Lev2 V Mem1. search.
%level_public_vars_rf
  %S-RfEnd
   case Vars. case Mem.
  %S-RfAdd
   Vars1: case Vars. apply join_public to Lev3.
   Or: apply mem_append to Mem Vars3. Mem': case Or.
     %mem DE
      apply IH to Lev1 Vars2 Mem'. search.
     %mem DRest
      apply IH1 to Lev2 Vars1 Mem'. search.
  %Preservability
   V: apply trans_rf_vars_exist to Lev1 Vars.
   Mem: apply trans_rf_vars to Lev1 Vars V Mem.
   apply IH1 to Lev2 V Mem1. search.

Define public_equiv :
   list (pair string seclevel) -> list (pair string value) ->
   list (pair string value) -> prop by
public_equiv S G1 G2 :=
  forall X V1 V2,
      lookup S X public ->
      lookup G1 X V1 -> lookup G2 X V2 -> V1 = V2.


Theorem level_secure : forall SG G1 G2 E V1 V2,
  is_e E -> level SG E public -> public_equiv SG G1 G2 ->
  eval_e G1 E V1 -> eval_e G2 E V2 ->
  V1 = V2.
intros IsE Lev Equiv Ev1 Ev2. Vars: apply vars_exist to IsE.
Equiv: case Equiv. apply vars_eval_same_result to _ Vars Ev1 Ev2.
  intros Mem Lkp1 Lkp2. LkpS: apply level_public_vars to Lev Vars Mem.
  %
  apply Equiv to LkpS Lkp1 Lkp2. search.
search.


Extensible_Theorem
  stmt_private_no_public_change : forall C SG SG1 G G1,
    Sec : secure private SG C SG1 ->
    Ev : eval_c G C G1 ->
    public_equiv SG G G1
  on Ev.
%E-Noop
 skip.
%E-Seq
 skip.
%E-Declare
 skip.
%E-Assign
 skip.
%E-IfThenElseTrue
 skip.
%E-IfThenElseFalse
 skip.
%E-WhileFalse
 skip.
%E-WhileTrue
 skip.
%E-RecUpdate
 skip.
%E-DeclareSec
 skip.
%Preservability
 skip.


Extensible_Theorem
  stmt_secure : forall C PC SG SG1 GA GA' GB GB',
    Is : is_c C ->
    Sec : secure PC SG C SG1 ->
    Rel : public_equiv SG GA GB ->
    EvA : eval_c GA C GA' ->
    EvB : eval_c GB C GB' ->
    public_equiv SG1 GA' GB'
  on EvA. %Rel.
%E-Noop
 case EvB. case Sec. search.
%E-Seq
 EvB: case EvB. Sec: case Sec. Is: case Is.
 apply IH to _ _ _ EvA1 EvB. apply IH to _ _ _ EvA2 EvB1. search.
%E-Declare
 EvB: case EvB. Sec: case Sec. Is: case Is.
 apply level_secure to _ _ Rel EvA1 EvB. unfold.
 intros LkpSec LkpA LkpB. LkpA: case LkpA.
   %LkpA here
    LkpB: case LkpB.
      %LkpB here
       search.
      %LkpB later
       apply LkpB to _.
   %LkpA later
    LkpB: case LkpB.
      %LkpB here
       apply LkpA to _.
      %LkpB later
       Rel: case Rel. LkpSec: case LkpSec.
         %LkpSec here
          apply LkpA to _.
         %LkpSec later
          apply Rel to LkpSec1 LkpA1 LkpB1. search.
%E-Assign
 EvB: case EvB. Is: case Is.Sec: case Sec.
   %S-AssignPublic
    apply level_secure to _ Sec Rel EvA1 EvB. unfold.
    intros LkpSec LkpA LkpB. LkpA: case LkpA.
      %LkpA here
       LkpB: case LkpB.
         %LkpB here
          search.
         %LkpB later
          apply LkpB to _.
      %LkpA later
       LkpB: case LkpB.
         %LkpB here
          apply LkpA to _.
         %LkpB later
          Rel: case Rel. apply Rel to LkpSec LkpA1 LkpB1. search.
   %S-AssignPrivate
    unfold. intros LkpSec LkpA LkpB. LkpA: case LkpA.
      %LkpA here
       LkpB: case LkpB.
         %LkpB here
          apply lookup_unique to Sec1 LkpSec.
         %LkpB later
          apply LkpB to _.
      %LkpA later
       LkpB: case LkpB.
         %LkpB here
          apply LkpA to _.
         %LkpB later
          Rel: case Rel. apply Rel to LkpSec LkpA1 LkpB1. search.
%E-IfThenElseTrue
 Is: case Is. Sec: case Sec. EvB: case EvB.
   %EvB by E-IfThenElseTrue
    apply IH to _ _ _ EvA2 EvB1. skip.
   %EvB by E-IfThenElseFalse
    skip. %need another property
%E-IfThenElseFalse
 Is: case Is. Sec: case Sec. EvB: case EvB.
   %EvB by E-IfThenElseTrue
    skip. %need another property
   %EvB by E-IfThenElseFalse
    apply IH to _ _ _ EvA2 EvB1. skip.
%E-WhileFalse
 Is: case Is (keep). Sec: case Sec. EvB: case EvB.
   %EvB by E-WhileFalse
    search.
   %EvB by E-WhileTrue
    skip.
%E-WhileTrue
 Is: case Is (keep). Sec: case Sec. EvB: case EvB.
   %EvB by E-WhileFalse
    skip.
   %EvB by E-WhileTrue
    apply IH to _ _ _ EvA2 EvB1. skip.
%E-RecUpdate
 EvB: case EvB. Is: case Is. Sec: case Sec.
   %S-RecUpdatePublic
    apply level_secure to _ Sec Rel EvA1 EvB. Rel: case Rel.
    apply Rel to Sec1 EvA2 EvB1.
    apply update_rec_fields_unique to EvA3 EvB2. unfold.
    intros LkpSec LkpA LkpB. LkpA: case LkpA.
      %LkpA here
       LkpB: case LkpB.
         %LkpB here
          search.
         %LkpB later
          apply LkpB to _.
      %LkpA later
       LkpB: case LkpB.
         %LkpB here
          apply LkpA to _.
         %LkpB later
          apply Rel to LkpSec LkpA1 LkpB1. search.
   %S-RecUpdatePrivate
    unfold. intros LkpSec LkpA LkpB. LkpA: case LkpA.
      %LkpA here
       apply lookup_unique to Sec1 LkpSec.
      %LkpA later
       LkpB: case LkpB.
         %LkpB here
          apply LkpA to _.
         %LkpB later
          Rel: case Rel. apply Rel to LkpSec LkpA1 LkpB1. search.
%E-DeclareSec
 EvB: case EvB. Is: case Is. Sec: case Sec.
   %S-DeclareSecPrivate
    unfold. intros LkpSec LkpA LkpB. LkpSec: case LkpSec.
    LkpA: case LkpA.
      %LkpA here
       apply LkpSec to _.
      %LkpA later
       LkpB: case LkpB.
         %LkpB here
          apply LkpSec to _.
         %LkpB later
          Rel: case Rel. apply Rel to LkpSec1 LkpA1 LkpB1. search.
   %S-DeclareSecPublic
    apply level_secure to _ Sec Rel EvA1 EvB. unfold.
    intros LkpSec LkpA LkpB. LkpA: case LkpA.
      %LkpA here
       LkpB: case LkpB.
         %LkpB here
          search.
         %LkpB later
          apply LkpB to _.
      %LkpA later
       LkpB: case LkpB.
         %LkpB here
          apply LkpA to _.
         %LkpB later
          LkpSec: case LkpSec.
            %LkpSec here
             apply LkpA to _.
            %LkpSec later
             Rel: case Rel. apply Rel to LkpSec1 LkpA1 LkpB1. search.
%Preservability
 Sec: case Sec. apply trans_c_unique to EvA2 Sec.
 EvBTrans: apply trans_c_eval to EvA2 EvB.
 IsCT: apply trans_c_is to Sec Is.
 Equiv: apply IH to _ Sec1 Rel EvA1 EvBTrans.
 Equiv: case Equiv. unfold. intros LkpSec LkpA LkpB.
 LkpG': apply trans_c_eval_results to EvA2 EvB EvBTrans LkpB.
 apply Equiv to LkpSec LkpA LkpG'. search.
